<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hologram V6.0 Turbo</title>
    
    <style>
        /* --- æç®€åŸºç¡€æ ·å¼ --- */
        @font-face { font-family: 'TechMono'; src: local('Courier New'), local('Consolas'), monospace; }
        body { margin: 0; background: #000; overflow: hidden; font-family: 'TechMono', monospace; color: #00ffea; }
        
        /* å¼ºåˆ¶è§†é¢‘è§£ç  hack (iOSå¿…é¡») */
        #webcam { position: fixed; top: -2000px; left: -2000px; width: 320px; height: 240px; opacity: 0.01; pointer-events: none; }
        
        #hologram-canvas { position: absolute; inset: 0; z-index: 1; }
        
        /* --- åŠ è½½é®ç½© (æé€Ÿç‰ˆ) --- */
        #loading-screen {
            position: fixed; inset: 0; background: #000; z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.5s;
        }
        .loader-bar-bg {
            width: 200px; height: 4px; background: #333; border-radius: 2px; margin-top: 20px; overflow: hidden;
        }
        .loader-bar-fill {
            width: 0%; height: 100%; background: #00ffea; box-shadow: 0 0 10px #00ffea;
            transition: width 0.3s; animation: shimmy 2s infinite linear;
        }
        @keyframes shimmy { 0% {filter: hue-rotate(0deg);} 100% {filter: hue-rotate(360deg);} }
        
        /* --- HUD ç•Œé¢ --- */
        .hud-layer { position: absolute; z-index: 20; width: 100%; pointer-events: none; padding: 20px; box-sizing: border-box; }
        .hud-top { top: 0; display: flex; justify-content: space-between; border-bottom: 1px solid rgba(0,255,234,0.3); padding-bottom: 15px; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent); }
        .hud-bottom { bottom: 0; text-align: center; padding-bottom: 40px; background: linear-gradient(to top, rgba(0,0,0,0.9), transparent); }
        
        .back-btn { pointer-events: auto; color: #00ffea; border: 1px solid #00ffea; padding: 8px 15px; text-decoration: none; font-size: 12px; background: rgba(0,20,20,0.8); }
        
        #gesture-status { color: #fff; font-size: 10px; margin-top: 5px; opacity: 0.8; }
        
        /* è£…é¥°æŒ‰é’® */
        .left-dock { position: absolute; left: 15px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 15px; pointer-events: auto; z-index: 30; }
        .deco-btn { width: 40px; height: 40px; border-radius: 50%; border: 1px solid rgba(0,255,234,0.3); background: rgba(0,0,0,0.5); color: #00ffea; font-size: 18px; display: flex; justify-content: center; align-items: center; cursor: pointer; }
        
        /* å°çª—è°ƒè¯• */
        #webcam-wrapper { position: absolute; bottom: 130px; right: 20px; width: 100px; height: 75px; border: 1px solid #00ffea; opacity: 0.7; transform: scaleX(-1); z-index: 10; background: #000; }
        #webcam-preview { width: 100%; height: 100%; object-fit: cover; }
        
        #file-input { display: none; }
        .upload-btn { pointer-events: auto; border: 1px solid #00ffea; padding: 10px 30px; color: #00ffea; background: rgba(0,50,50,0.5); font-size: 12px; }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/+esm"
        }
    }
    </script>
</head>
<body>

    <div id="loading-screen">
        <div style="font-size: 20px; letter-spacing: 3px; text-shadow: 0 0 10px #00ffea;">HOLOGRAM LOADING</div>
        <div class="loader-bar-bg"><div class="loader-bar-fill" id="progress-bar"></div></div>
        <div id="loading-text" style="margin-top: 10px; font-size: 10px; color: #666;">Connecting to Satellite...</div>
    </div>

    <div class="hud-layer hud-top">
        <span>â— HOLOGRAM v6.0</span>
        <a href="mission.html" class="back-btn">EXIT</a>
    </div>

    <canvas id="hologram-canvas"></canvas>

    <div class="left-dock">
        <div class="deco-btn" onclick="addDeco('STAR')">â˜…</div>
        <div class="deco-btn" onclick="addDeco('GIFT')">ğŸ</div>
        <div class="deco-btn" onclick="addDeco('SOCK')">ğŸ§¦</div>
    </div>

    <div id="webcam-wrapper"><canvas id="webcam-preview"></canvas></div>
    <video id="webcam" autoplay playsinline muted></video>

    <div class="hud-layer hud-bottom">
        <label class="upload-btn">ğŸ“· UPLOAD MEMORY<input type="file" id="file-input" multiple accept="image/*"></label>
        <div id="gesture-status">WAITING FOR CAMERA...</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // UI refs
        const loadingScreen = document.getElementById('loading-screen');
        const progressBar = document.getElementById('progress-bar');
        const loadText = document.getElementById('loading-text');
        
        // State
        let handLandmarker = undefined;
        let video = document.getElementById('webcam');
        let lastVideoTime = -1;
        
        // ä¼ªè¿›åº¦æ¡ (å¿ƒç†å­¦ä¼˜åŒ–)
        let progress = 0;
        const fakeProgress = setInterval(() => {
            if(progress < 90) {
                progress += Math.random() * 5;
                progressBar.style.width = progress + '%';
            }
        }, 200);

        // --- 1. æé€Ÿåˆå§‹åŒ– ---
        async function launchSystem() {
            try {
                loadText.innerText = "Downloading Engine (CDN)...";
                
                // å¹¶è¡Œä»»åŠ¡ï¼šè¯·æ±‚æ‘„åƒå¤´ + ä¸‹è½½æ¨¡å‹
                const cameraTask = startCamera();
                const aiTask = loadAI();
                
                await Promise.all([cameraTask, aiTask]);
                
                // å®Œæˆ
                clearInterval(fakeProgress);
                progressBar.style.width = '100%';
                loadText.innerText = "READY!";
                
                setTimeout(() => {
                    loadingScreen.style.opacity = 0;
                    setTimeout(() => loadingScreen.remove(), 500);
                    startLoop(); // å¯åŠ¨æ¸²æŸ“å¾ªç¯
                }, 500);

            } catch (error) {
                loadText.innerText = "ERROR: " + error.message;
                loadText.style.color = "red";
                console.error(error);
            }
        }

        // --- 2. æ‘„åƒå¤´å¯åŠ¨ (å¸¦ iOS ä¿®å¤) ---
        async function startCamera() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error("No Camera API");
            }
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: "user", width: {ideal: 320}, height: {ideal: 240} }
            });
            video.srcObject = stream;
            return new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    video.play();
                    resolve();
                };
            });
        }

        // --- 3. AI åŠ è½½ (CDN + æœ¬åœ° Lite) ---
        async function loadAI() {
            // ä½¿ç”¨ jsDelivr æé€ŸåŠ è½½ WASM å¼•æ“
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm"
            );
            
            // åŠ è½½æœ¬åœ°çš„ Lite æ¨¡å‹ (ç¡®ä¿æ‚¨å·²ä¸Šä¼ äº†é‚£ä¸ª 1MB çš„æ–‡ä»¶)
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "./wasm/hand_landmarker.task", 
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
        }

        // --- 4. Three.js æ¸²æŸ“é€»è¾‘ (ç²¾ç®€ç‰ˆä½†åŠŸèƒ½å®Œæ•´) ---
        // (ä¸ºäº†ç¡®ä¿ä»£ç ä¸è¶…é•¿ä¸”æ—  bugï¼Œè¿™é‡Œä½¿ç”¨äº†æœ€ç¨³å®šçš„æ¸²æŸ“æ ¸å¿ƒ)
        const scene = new THREE.Scene(); 
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 40);
        const renderer = new THREE.WebGLRenderer({canvas: document.getElementById('hologram-canvas'), alpha:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85));

        const group = new THREE.Group(); scene.add(group);
        
        // é€ æ ‘
        const particles = [];
        const geo = new THREE.TetrahedronGeometry(0.5);
        const mat = new THREE.MeshBasicMaterial({color: 0x00ffea});
        for(let i=0; i<800; i++) {
            const mesh = new THREE.Mesh(geo, mat);
            const t = Math.random(); const y = t*30 - 15; const r = (1-t)*10; const a = Math.random()*6.28;
            mesh.position.set(Math.cos(a)*r, y, Math.sin(a)*r);
            mesh.userData = { 
                basePos: mesh.position.clone(),
                scatterPos: new THREE.Vector3((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50)
            };
            group.add(mesh);
            particles.push(mesh);
        }

        // è£…é¥°åŠŸèƒ½
        window.addDeco = (type) => {
            const d = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshBasicMaterial({color:0xff0000}));
            d.position.set((Math.random()-0.5)*10, Math.random()*10, 5);
            group.add(d);
        }

        // å¾ªç¯
        const webcamCtx = document.getElementById('webcam-preview').getContext('2d');
        document.getElementById('webcam-preview').width = 160;
        document.getElementById('webcam-preview').height = 120;

        function startLoop() {
            function render() {
                // AI é¢„æµ‹
                if (video.readyState >= 2 && handLandmarker) {
                    let results = handLandmarker.detectForVideo(video, performance.now());
                    
                    // è°ƒè¯•çª—å£
                    webcamCtx.drawImage(video, 0, 0, 160, 120);
                    
                    if(results.landmarks.length > 0) {
                        const lm = results.landmarks[0];
                        // ç®€å•æ‰‹åŠ¿ï¼šåˆ¤æ–­å¼ å¼€è¿˜æ˜¯æ¡æ‹³
                        const wrist = lm[0]; const tip = lm[12]; // ä¸­æŒ‡
                        const dist = Math.hypot(tip.x-wrist.x, tip.y-wrist.y);
                        
                        document.getElementById('gesture-status').innerText = dist > 0.3 ? "HAND: OPEN (SCATTER)" : "HAND: CLOSED (SPIN)";
                        
                        if (dist > 0.3) {
                            // æ•£å¼€
                            particles.forEach(p => p.position.lerp(p.userData.scatterPos, 0.1));
                        } else {
                            // è¿˜åŸ + æ—‹è½¬
                            particles.forEach(p => p.position.lerp(p.userData.basePos, 0.1));
                            group.rotation.y += 0.05;
                        }
                    } else {
                        document.getElementById('gesture-status').innerText = "NO HAND DETECTED";
                        group.rotation.y += 0.01; // è‡ªåŠ¨æ—‹è½¬
                        particles.forEach(p => p.position.lerp(p.userData.basePos, 0.05));
                    }
                }
                
                composer.render();
                requestAnimationFrame(render);
            }
            render();
        }

        // ä¸Šä¼ ç…§ç‰‡é€»è¾‘
        document.getElementById('file-input').addEventListener('change', (e) => {
            if(e.target.files[0]) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const tex = new THREE.TextureLoader().load(ev.target.result);
                    const photo = new THREE.Mesh(new THREE.PlaneGeometry(5,5), new THREE.MeshBasicMaterial({map:tex}));
                    group.add(photo);
                };
                reader.readAsDataURL(e.target.files[0]);
            }
        });

        // å¯åŠ¨
        launchSystem();
    </script>
</body>
</html>
