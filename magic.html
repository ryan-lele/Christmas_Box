<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hologram Projector V5.2 iOS Fix</title>
    
    <style>
        /* --- Â≠ó‰Ωì‰∏éÂü∫Á°Ä --- */
        @font-face { font-family: 'TechMono'; src: local('Courier New'), local('Consolas'), monospace; }
        
        body { 
            margin: 0; padding: 0; background-color: #000; overflow: hidden; 
            font-family: 'TechMono', monospace; color: #00ffea; height: 100vh; width: 100vw;
            background-image: linear-gradient(rgba(0, 255, 234, 0.03) 1px, transparent 1px);
            background-size: 100% 4px;
        }

        /* --- ÂÖ®ÊÅØÁîªÂ∏É --- */
        #hologram-canvas { position: absolute; top: 0; left: 0; z-index: 1; width: 100%; height: 100%; }

        /* --- HUD ÁïåÈù¢Á≥ªÁªü --- */
        .hud-layer { position: absolute; z-index: 20; width: 100%; pointer-events: none; padding: 20px; box-sizing: border-box; }
        
        .hud-top { 
            top: 0; display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            border-bottom: 1px solid rgba(0, 255, 234, 0.3); padding-bottom: 15px;
        }
        .hud-bottom { 
            bottom: 0; text-align: center; 
            background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
            padding-bottom: 30px; padding-top: 40px;
        }

        .status-dot {
            display: inline-block; width: 8px; height: 8px;
            background-color: #00ffea; border-radius: 50%;
            box-shadow: 0 0 10px #00ffea, 0 0 20px #00ffea; margin-right: 8px;
            animation: blink 2s infinite;
        }
        @keyframes blink { 0%, 100% {opacity: 1;} 50% {opacity: 0.3;} }

        .back-btn {
            pointer-events: auto; text-decoration: none;
            color: #00ffea; border: 1px solid #00ffea;
            padding: 8px 16px; font-size: 12px; letter-spacing: 1px;
            background: rgba(0, 40, 40, 0.6); backdrop-filter: blur(4px);
            transition: all 0.3s; clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }

        .left-dock {
            position: absolute; left: 20px; top: 50%; transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 15px; pointer-events: auto; z-index: 25;
        }
        .deco-btn {
            width: 45px; height: 45px; border-radius: 50%;
            background: rgba(0, 20, 20, 0.6); border: 1px solid rgba(0, 255, 234, 0.3);
            color: #00ffea; font-size: 20px; display: flex; justify-content: center; align-items: center;
            cursor: pointer; transition: all 0.2s; box-shadow: 0 0 10px rgba(0, 255, 234, 0.1);
        }
        .deco-btn:hover { transform: scale(1.1); background: rgba(0, 255, 234, 0.2); box-shadow: 0 0 20px rgba(0, 255, 234, 0.4); border-color: #00ffea; }

        /* ÊëÑÂÉèÂ§¥Â∞èÁ™ó (Áîª‰∏≠Áîª) - Áî®‰∫éË∞ÉËØïÁúãÊòØÂê¶ÊúâÁîªÈù¢ */
        #webcam-wrapper { 
            position: absolute; bottom: 120px; right: 20px; width: 120px; height: 90px; 
            border: 1px solid #00ffea; background: #000; z-index: 15; opacity: 0.8;
            box-shadow: 0 0 15px rgba(0, 255, 234, 0.2); transform: scaleX(-1);
        }
        #webcam-preview { width: 100%; height: 100%; object-fit: cover; }
        #gesture-status { 
            position: absolute; bottom: 0; left: 0; width: 100%; 
            background: rgba(0, 255, 234, 0.8); color: #000; 
            font-size: 9px; font-weight: bold; text-align: center; 
        }

        .upload-btn {
            pointer-events: auto; display: inline-block;
            background: linear-gradient(90deg, rgba(0, 100, 255, 0.3), rgba(0, 255, 234, 0.3));
            border: 1px solid #00ffea; color: #e0ffff;
            padding: 10px 30px; border-radius: 4px;
            font-family: 'TechMono', monospace; font-size: 12px; letter-spacing: 1px;
            cursor: pointer; box-shadow: 0 0 20px rgba(0, 255, 234, 0.2);
            position: relative; overflow: hidden;
        }
        .upload-btn::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: scan-light 3s infinite;
        }
        @keyframes scan-light { 0% {left: -100%;} 20% {left: 100%;} 100% {left: 100%;} }
        .holo-scan {
            position: absolute; top: 0; left: 0; width: 100%; height: 5px;
            background: #00ffea; opacity: 0.3; box-shadow: 0 0 20px #00ffea;
            animation: scanning 4s linear infinite; pointer-events: none; z-index: 10;
        }
        @keyframes scanning { 0% {top: -10%; opacity: 0;} 10% {opacity: 0.5;} 90% {opacity: 0.5;} 100% {top: 110%; opacity: 0;} }

        #file-input { display: none; }
        
        /* --- V5.2 ÂÖ≥ÈîÆ‰øÆÂ§çÔºöiOS Safari Âº∫Âà∂Ëß£Á†Å Hack --- */
        /* Â∞ÜËßÜÈ¢ëÁßªÂá∫Â±èÂπïÂ§ñÔºå‰ΩÜ‰øùÊåÅÁúüÂÆûÂ∞∫ÂØ∏ÂíåÂì™ÊÄï‰∏ÄÁÇπÁÇπÈÄèÊòéÂ∫¶ */
        /* ËøôÊ†∑ Safari Â∞±‰ºöË¢´Ëø´ËÆ§‰∏∫ÂÆÉÈúÄË¶ÅË¢´Ê∏≤ÊüìÔºå‰ªéËÄå‰øùÊåÅËß£Á†Å */
        #webcam { 
            position: fixed;
            top: -1000px; left: -1000px;
            width: 160px; height: 120px;
            opacity: 0.01;
            pointer-events: none;
            z-index: -999;
        }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://registry.npmmirror.com/three/0.160.0/files/build/three.module.js",
            "three/addons/": "https://registry.npmmirror.com/three/0.160.0/files/examples/jsm/",
            "@mediapipe/tasks-vision": "./js/vision_bundle.js"
        }
    }
    </script>
</head>
<body>

    <div class="holo-scan"></div>

    <div class="hud-layer hud-top">
        <div style="display:flex; align-items:center;">
            <span class="status-dot"></span>
            <span id="txt-proj" style="font-size:14px; letter-spacing:2px; text-shadow:0 0 10px #00ffea;">HOLOGRAM v5.2</span>
        </div>
        <a href="mission.html" class="back-btn" id="txt-exit">‚Üê BACK</a>
    </div>

    <canvas id="hologram-canvas"></canvas>

    <div class="left-dock">
        <button class="deco-btn" id="btn-add-star">‚òÖ</button>
        <button class="deco-btn" id="btn-add-gift">üéÅ</button>
        <button class="deco-btn" id="btn-add-sock">üß¶</button>
        <button class="deco-btn" id="btn-add-apple">üçé</button>
        <button class="deco-btn" id="btn-add-bauble">‚óè</button>
    </div>

    <div id="webcam-wrapper">
        <canvas id="webcam-preview"></canvas>
        <div id="gesture-status">SYSTEM INIT...</div>
    </div>
    
    <video id="webcam" autoplay playsinline muted></video>

    <div class="hud-layer hud-bottom">
        <label class="upload-btn">
            <span id="txt-upload">üì∑ UPLOAD MEMORY</span>
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
        
        <div style="margin-top: 15px; color: rgba(0,255,234,0.7);">
            <div id="txt-sys" style="font-size:10px; letter-spacing:1px;">// SYSTEM: PARTICLE ENGINE ONLINE</div>
            <div style="margin-top:5px;">
                <span id="txt-target" style="color:#fff;">// TARGET: </span> 
                <span id="target-name" style="color:#00ffea; font-weight:bold; text-shadow:0 0 10px cyan;">UNKNOWN</span>
            </div>
            <div id="txt-gesture" style="color: #fff; text-shadow: 0 0 5px cyan; font-size: 12px; margin-top:10px; font-weight:bold; letter-spacing: 1px;">
                Downloading AI Model (Wait)...
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- ÂèÇÊï∞Ëß£Êûê‰∏éÂ≠óÂÖ∏ ---
        const urlParams = new URLSearchParams(window.location.search);
        const childName = urlParams.get('name') || 'USER';
        const lang = urlParams.get('lang') || 'zh';
        document.getElementById('target-name').innerText = childName.toUpperCase();

        const dict = {
            zh: { proj: "ÂÖ®ÊÅØÊäïÂΩ± v5.2", exit: "ËøîÂõû‰ªªÂä°", sys: "// Á≥ªÁªü: Á≤íÂ≠êÂºïÊìéÂ∑≤Â∞±Áª™", target: "// ÈîÅÂÆöÁõÆÊ†á: ", upload: "üì∑ ‰∏ä‰º†ÁÖßÁâá (ÁîüÊàêÁ≤íÂ≠ê)", status_ready: "ËßÜËßâÁ≥ªÁªüÊ≠£Â∏∏", hint: "‚úãÂº†ÂºÄ:Êï£ÂºÄ | ‚òùÔ∏èÂçïÊåá:ÁúãÁÖßÁâá | ‚úäÊè°Êã≥:ËøòÂéü", loading: "Ê≠£Âú®‰∏ãËΩΩAIÊ®°Âûã (È¶ñÊ¨°ÈúÄ1ÂàÜÈíü)...", req: "ËØ∑Ê±ÇÊëÑÂÉèÂ§¥ÊùÉÈôê..." },
            en: { proj: "HOLOGRAM v5.2", exit: "BACK", sys: "// SYSTEM: ENGINE ONLINE", target: "// TARGET: ", upload: "üì∑ UPLOAD MEMORY", status_ready: "VISUAL OK", hint: "‚úã OPEN: Scatter | ‚òùÔ∏è POINT: View | ‚úä FIST: Reset", loading: "Downloading AI (Wait 1min)...", req: "Requesting Camera..." }
        };
        const t = dict[lang];
        document.getElementById('txt-proj').innerText = t.proj; document.getElementById('txt-exit').innerText = t.exit; document.getElementById('txt-sys').innerText = t.sys; document.getElementById('txt-target').innerText = t.target; document.getElementById('txt-upload').innerText = t.upload; document.getElementById('txt-gesture').innerText = t.loading;

        // --- Three.js Setup ---
        const CONFIG = { colors: { bg: 0x000000, blueMain: 0x00ffea, whiteSilver: 0xffffff }, tree: { height: 26, radius: 9, count: 1200 }, fairyDust: { count: 800 } };
        const STATE = { mode: 'TREE', focusIndex: 0, hand: { detected: false }, rotationVelocity: 0, targetGroupPos: new THREE.Vector3(0,0,0) };
        let swipe = { lastX: null, lastTime: 0, cooldown: 500 };
        let scene, camera, renderer, composer, mainGroup, treeGroup, snowSystem, lightTubeMesh;
        let particles = [], photoMeshes = [];
        let glowTex, snowTex, giftTex, sockTex, appleTex, baseBlueMat, baseSilverMat, starGeo, ballGeo;
        let clock = new THREE.Clock();
        let handLandmarker, video, webcamCanvas, webcamCtx;

        async function init() {
            createResources(); initThree(); setupLights(); 
            createTreeLeaves(); createFairyDust(); createStringLights(); createDecorations(); createMagicRings(); createTopStar(); createDefaultPhoto(); createSnow();
            setupPostProcessing(); setupEvents(); animate();
            initMediaPipe().catch(err => {
                console.error(err);
                document.getElementById('txt-gesture').innerText = "‚ùå AIÂêØÂä®Â§±Ë¥• (ËØ∑Âà∑Êñ∞ÈáçËØï)";
                document.getElementById('gesture-status').innerText = "ERROR"; document.getElementById('gesture-status').style.color = "red";
            });
        }

        function createEmojiTexture(e,s=64){const c=document.createElement('canvas');c.width=s;c.height=s;const x=c.getContext('2d');x.font=`${s*0.8}px serif`;x.textAlign='center';x.textBaseline='middle';x.fillText(e,s/2,s/2+s*0.1);return new THREE.CanvasTexture(c);}
        function createResources(){
            const c=document.createElement('canvas');c.width=64;c.height=64;const x=c.getContext('2d');const g=x.createRadialGradient(32,32,0,32,32,32);g.addColorStop(0,'rgba(255,255,255,1)');g.addColorStop(0.4,'rgba(0,255,234,0.5)');g.addColorStop(1,'rgba(0,0,0,0)');x.fillStyle=g;x.fillRect(0,0,64,64);glowTex=new THREE.CanvasTexture(c);
            snowTex=createEmojiTexture('‚ùÑÔ∏è'); giftTex=createEmojiTexture('üéÅ'); sockTex=createEmojiTexture('üß¶'); appleTex=createEmojiTexture('üçé');
            baseBlueMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.blueMain, roughness: 0.3, metalness: 0.7, emissive: 0x0044aa, emissiveIntensity: 0.2 });
            baseSilverMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.whiteSilver, roughness: 0.2, metalness: 0.9, emissive: 0x444455, emissiveIntensity: 0.2 });
            ballGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const sShape = new THREE.Shape(); for(let i=0; i<10; i++) { const r = i%2===0 ? 0.6 : 0.3; const a = i/10 * Math.PI*2; sShape.lineTo(Math.cos(a)*r, Math.sin(a)*r); } starGeo = new THREE.ExtrudeGeometry(sShape, { depth: 0.15, bevelEnabled:true, bevelThickness:0.05 });
        }
        function initThree() {
            const cvs = document.getElementById('hologram-canvas');
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x000000, 0.02);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 50); camera.lookAt(0, 8, 0);
            renderer = new THREE.WebGLRenderer({ canvas: cvs, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping; renderer.toneMappingExposure = 2.0;
            mainGroup = new THREE.Group(); treeGroup = new THREE.Group(); mainGroup.add(treeGroup); scene.add(mainGroup);
        }
        function setupLights() { const ambient = new THREE.AmbientLight(0x00ffff, 0.5); scene.add(ambient); const spot = new THREE.SpotLight(0x00ffea, 50); spot.position.set(30, 60, 50); scene.add(spot); }
        class Particle {
            constructor(mesh, type) {
                this.mesh = mesh; this.type = type; this.basePos = mesh.position.clone(); this.baseScale = mesh.scale.x; this.baseRot = mesh.rotation.clone(); this.blinkSpeed = 2 + Math.random() * 3;
                const r = (type === 'FAIRY' ? 10 : 25) + Math.random()*10; const theta = Math.random()*Math.PI*2; const phi = Math.acos(2*Math.random()-1);
                this.scatterPos = new THREE.Vector3(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta)+2, r*Math.cos(phi));
            }
            update(dt, time) {
                if(this.type !== 'PHOTO' && this.mesh.material.emissive) this.mesh.material.emissiveIntensity = 0.5 + 0.5*Math.sin(time*this.blinkSpeed);
                let targetPos = (STATE.mode==='SCATTER' || STATE.mode==='FOCUS') ? this.scatterPos : this.basePos;
                let targetScale = this.baseScale;
                if(STATE.mode==='FOCUS' && this.type==='PHOTO') {
                    if(this.mesh === photoMeshes[STATE.focusIndex].mesh) { const inv = new THREE.Matrix4().copy(treeGroup.matrixWorld).invert(); targetPos = new THREE.Vector3(0,5,40).applyMatrix4(inv); targetScale = 5.0; this.mesh.lookAt(camera.position); } else targetScale = 0;
                }
                this.mesh.position.lerp(targetPos, 4*dt); this.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 4*dt);
                if(STATE.mode==='TREE') this.mesh.rotation.y += dt; 
            }
        }
        function createTreeLeaves() { const geo = new THREE.TetrahedronGeometry(0.4, 0); for(let i=0; i<CONFIG.tree.count; i++) { const t = Math.random(); const h = CONFIG.tree.height; const r = CONFIG.tree.radius * (1-t); const y = t*h - h/2 + 2; const a = Math.random() * Math.PI*2; const p = new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r); const mat = Math.random()>0.6 ? baseSilverMat.clone() : baseBlueMat.clone(); const mesh = new THREE.Mesh(geo, mat); mesh.position.copy(p); mesh.scale.setScalar(Math.random()*0.8+0.2); treeGroup.add(mesh); particles.push(new Particle(mesh, 'LEAF')); } }
        function createFairyDust() { const mat = new THREE.SpriteMaterial({ map: glowTex, color: 0xffffff, transparent: true, blending: THREE.AdditiveBlending }); for(let i=0; i<CONFIG.fairyDust.count; i++) { const s = new THREE.Sprite(mat); const t = Math.random(); const r = CONFIG.tree.radius*(1-t)*0.8; const y = t*CONFIG.tree.height - CONFIG.tree.height/2 + 2; const a = Math.random()*Math.PI*2; s.position.set(Math.cos(a)*r, y, Math.sin(a)*r); s.scale.setScalar(0.5); treeGroup.add(s); particles.push(new Particle(s, 'FAIRY')); } }
        function createStringLights() { const curvePts = []; const h = CONFIG.tree.height; for(let i=0; i<=200; i++) { const t = i/200; const a = t*7*Math.PI*2; const y = t*h-h/2+1; const r = CONFIG.tree.radius*(1-t)+0.4; curvePts.push(new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r)); } const curve = new THREE.CatmullRomCurve3(curvePts); lightTubeMesh = new THREE.Mesh(new THREE.TubeGeometry(curve, 120, 0.05, 8, false), new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent:true, opacity:0.3 })); treeGroup.add(lightTubeMesh); const bulbGeo = new THREE.SphereGeometry(0.15); const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); for(let i=0; i<150; i++) { const pt = curve.getPoint(i/150); const mesh = new THREE.Mesh(bulbGeo, bulbMat.clone()); mesh.position.copy(pt); mesh.userData.blinkRate = 2+Math.random()*3; treeGroup.add(mesh); particles.push(new Particle(mesh, 'LIGHT')); scene.userData.bulbs = scene.userData.bulbs || []; scene.userData.bulbs.push(mesh); } }
        function createDecorations() { for(let i=0;i<3;i++) addDecoration('STAR'); for(let i=0;i<3;i++) addDecoration('GIFT'); for(let i=0;i<5;i++) addDecoration('BAUBLE'); }
        function addDecoration(type) { let mesh; const t = Math.random(); const h = CONFIG.tree.height; const y = t*h-h/2+2; const r = CONFIG.tree.radius*(1-t)+1.2; const a = Math.random()*Math.PI*2; const pos = new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r); if(type === 'STAR') { mesh = new THREE.Mesh(starGeo, baseSilverMat.clone()); mesh.scale.setScalar(1.3); } else if (type === 'GIFT') { mesh = new THREE.Sprite(new THREE.SpriteMaterial({ map: giftTex })); mesh.scale.setScalar(2.0); } else if (type === 'SOCK') { mesh = new THREE.Sprite(new THREE.SpriteMaterial({ map: sockTex })); mesh.scale.setScalar(2.0); } else if (type === 'APPLE') { mesh = new THREE.Sprite(new THREE.SpriteMaterial({ map: appleTex })); mesh.scale.setScalar(1.8); } else { mesh = new THREE.Mesh(ballGeo, Math.random()>0.5 ? baseBlueMat.clone() : baseSilverMat.clone()); mesh.scale.setScalar(0.8); } mesh.position.copy(pos); if(mesh.isMesh) mesh.lookAt(0, y, 0); treeGroup.add(mesh); const p = new Particle(mesh, 'DECO_'+type); p.baseScale = mesh.scale.x; mesh.scale.set(0,0,0); particles.push(p); }
        function createTopStar() { const geo = new THREE.OctahedronGeometry(1.5, 0); const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x88ccff, emissiveIntensity: 2 }); const star = new THREE.Mesh(geo, mat); star.position.set(0, CONFIG.tree.height/2+2.5, 0); treeGroup.add(star); }
        function createDefaultPhoto() { const cvs = document.createElement('canvas'); cvs.width=512; cvs.height=512; const x=cvs.getContext('2d'); x.fillStyle='#001133'; x.fillRect(0,0,512,512); x.strokeStyle='#00ffea'; x.lineWidth=20; x.strokeRect(20,20,472,472); x.font='80px Arial'; x.fillStyle='#fff'; x.textAlign='center'; x.fillText("Merry", 256, 200); x.fillText("Christmas", 256, 300); addPhotoMesh(new THREE.CanvasTexture(cvs), 1); }
        function addPhotoMesh(tex, aspect) { const g = new THREE.Group(); const m = new THREE.Mesh(new THREE.PlaneGeometry(1,1), new THREE.MeshBasicMaterial({map:tex, side:THREE.DoubleSide})); const f = new THREE.Mesh(new THREE.BoxGeometry(1.1,1.1,0.05), new THREE.MeshBasicMaterial({color:0x00ffea})); f.position.z=-0.03; g.add(m); g.add(f); const t = Math.random(); const h = CONFIG.tree.height; const y = t*(h-6)-(h/2-3); const r = CONFIG.tree.radius+2.5; const angle = Math.random()*Math.PI*2; g.position.set(Math.cos(angle)*r, y, Math.sin(angle)*r); g.lookAt(0,y,0); g.rotateY(Math.PI); treeGroup.add(g); particles.push(new Particle(g, 'PHOTO')); photoMeshes.push({mesh:g, aspect:aspect}); }
        function createMagicRings() { const g = new THREE.TorusGeometry(10, 0.05, 16, 100); const m = new THREE.MeshBasicMaterial({color: 0x00ffea, transparent:true, opacity:0.3}); for(let i=0; i<3; i++) { const r1 = new THREE.Mesh(g, m); r1.rotation.x = Math.PI/2; r1.position.y = -CONFIG.tree.height/2-1; r1.scale.setScalar(1+i*0.5); scene.add(r1); } }
        function createSnow() { const geo = new THREE.BufferGeometry(); const pos = []; for(let i=0; i<2000; i++) pos.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100); geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3)); snowSystem = new THREE.Points(geo, new THREE.PointsMaterial({color:0xffffff, size:0.5, transparent:true, opacity:0.6})); scene.add(snowSystem); }
        function setupPostProcessing() { const rp = new RenderPass(scene, camera); const bp = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85); bp.threshold = 0; bp.strength = 1.2; bp.radius = 0.5; composer = new EffectComposer(renderer); composer.addPass(rp); composer.addPass(bp); }
        function setupEvents() { window.addEventListener('resize', ()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); composer.setSize(window.innerWidth,window.innerHeight); }); const input = document.getElementById('file-input'); input.addEventListener('change', (e)=>{ if(e.target.files && e.target.files[0]) { Array.from(e.target.files).forEach(file => { const reader = new FileReader(); reader.onload=(ev)=>{ const img = new Image(); img.src=ev.target.result; img.onload=()=>{ new THREE.TextureLoader().load(ev.target.result, (tex)=>{ tex.colorSpace = THREE.SRGBColorSpace; addPhotoMesh(tex, img.width/img.height); STATE.focusIndex = photoMeshes.length-1; document.getElementById('txt-gesture').innerText = "Photo Ready! Point ‚òùÔ∏è to view."; }); } }; reader.readAsDataURL(file); }); input.value = ''; } }); ['star','gift','sock','apple','bauble'].forEach(k=>{ document.getElementById('btn-add-'+k).onclick=()=>addDecoration(k.toUpperCase()); }); }

        // --- V5.2 Ê†∏ÂøÉ‰øÆÂ§çÔºöAI ‰∏éÊëÑÂÉèÂ§¥ ---
        async function initMediaPipe() {
            video = document.getElementById('webcam'); webcamCanvas = document.getElementById('webcam-preview'); webcamCtx = webcamCanvas.getContext('2d');
            webcamCanvas.width=160; webcamCanvas.height=120;

            try {
                const vision = await FilesetResolver.forVisionTasks("./wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: "./wasm/hand_landmarker.task", delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });

                document.getElementById('txt-gesture').innerText = t.req;

                if(navigator.mediaDevices?.getUserMedia) {
                    // V5.2 ‰øÆÂ§çÔºöÁßªÈô§Âº∫Âà∂ÂàÜËæ®ÁéáÔºåËÆ©ÊâãÊú∫Ëá™Â∑±ÂÜ≥ÂÆö
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: "user" }
                    });
                    video.srcObject = stream;
                    
                    // iOS ÂÖ≥ÈîÆÁÇπÔºöÁ≠âÂæÖ metadata Âä†ËΩΩÂÆåÊØïÂêéÂÜçÂºÄÂßãÈ¢ÑÊµã
                    video.onloadedmetadata = () => {
                        video.play(); // ÂÜçÊ¨°Âº∫Âà∂Êí≠Êîæ
                        predictWebcam();
                        document.getElementById('gesture-status').innerText = t.status_ready;
                        document.getElementById('txt-gesture').innerText = t.hint;
                    };
                }
            } catch(e) {
                console.error(e);
                document.getElementById('txt-gesture').innerText = "‚ùå AIÂêØÂä®Â§±Ë¥• (ËØ∑Á°Æ‰øùÁΩëÁªúÈÄöÁïÖ)";
            }
        }

        let lastTime = -1;
        async function predictWebcam() {
            // Á°Æ‰øù video Ê≠£Âú®Êí≠Êîæ‰∏îÊúâÊï∞ÊçÆ
            if(video.currentTime !== lastTime && video.readyState >= 2 && handLandmarker) {
                lastTime = video.currentTime;
                
                let results;
                try { results = handLandmarker.detectForVideo(video, performance.now()); } catch(e) { console.error(e); }

                // Ë∞ÉËØïÂ∞èÁ™óÁªòÂà∂
                webcamCtx.clearRect(0,0,160,120);
                webcamCtx.drawImage(video, 0, 0, 160, 120);

                if(results && results.landmarks.length > 0) {
                    processGestures(results.landmarks[0]);
                    webcamCtx.fillStyle = '#00ffea'; for(let p of results.landmarks[0]) { webcamCtx.beginPath(); webcamCtx.arc(p.x*160, p.y*120, 2, 0, 2*Math.PI); webcamCtx.fill(); }
                } else {
                    STATE.hand.detected = false;
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        function processGestures(lm) {
            STATE.hand.detected = true;
            const wrist = lm[0]; const tips = [lm[8], lm[12], lm[16], lm[20]]; let spread = 0; tips.forEach(t => spread += Math.hypot(t.x-wrist.x, t.y-wrist.y)); spread/=4; const palmX = (lm[9].x - 0.5)*2; const palmY = (lm[9].y - 0.5)*2;
            if(spread < 0.25) { STATE.mode = 'TREE'; STATE.targetGroupPos.set(0,0,0); STATE.rotationVelocity = THREE.MathUtils.lerp(STATE.rotationVelocity, -palmX * 3.0, 0.1); document.getElementById('txt-gesture').innerText = t.hint.split('|')[2].trim(); } 
            else if (spread > 0.55) { STATE.mode = 'SCATTER'; STATE.targetGroupPos.x = -palmX * 20; STATE.targetGroupPos.y = palmY * 15; STATE.rotationVelocity = -palmX * 2.0; document.getElementById('txt-gesture').innerText = t.hint.split('|')[0].trim(); } 
            else { STATE.mode = 'FOCUS'; if(STATE.mode === 'FOCUS') STATE.focusIndex = findClosestPhotoIndex(); if (swipe.lastX !== null) { const diff = lm[8].x - swipe.lastX; if (diff > 0.05) switchPhoto(-1); else if (diff < -0.05) switchPhoto(1); } swipe.lastX = lm[8].x; document.getElementById('txt-gesture').innerText = t.hint.split('|')[1].trim(); }
        }
        function findClosestPhotoIndex() { let closestIndex = 0; let minDistance = Infinity; photoMeshes.forEach((item, index) => { const worldPos = new THREE.Vector3(); item.mesh.getWorldPosition(worldPos); const dist = camera.position.distanceTo(worldPos); if(dist < minDistance) { minDistance = dist; closestIndex = index; } }); return closestIndex; }
        function switchPhoto(dir) { const now = performance.now(); if (now - swipe.lastTime < swipe.cooldown) return; const len = photoMeshes.length; if (len === 0) return; STATE.focusIndex = (STATE.focusIndex + dir + len) % len; swipe.lastTime = now; }

        function animate() {
            requestAnimationFrame(animate); const dt = clock.getDelta(); const time = clock.elapsedTime;
            if(STATE.mode !== 'FOCUS') { treeGroup.rotation.y += STATE.rotationVelocity * dt; treeGroup.position.lerp(STATE.targetGroupPos, 2*dt); }
            particles.forEach(p => p.update(dt, time)); if(lightTubeMesh) lightTubeMesh.visible = (STATE.mode === 'TREE');
            if(snowSystem) { const pos = snowSystem.geometry.attributes.position.array; for(let i=1; i<pos.length; i+=3) { pos[i] -= 5*dt; if(pos[i]<-50) pos[i]=50; } snowSystem.geometry.attributes.position.needsUpdate = true; }
            if (scene.userData.bulbs) scene.userData.bulbs.forEach(b => b.material.color.setHSL(0.6, 1.0, 0.5 + 0.5*Math.sin(time*b.userData.blinkRate)));
            composer.render();
        }
        init();
    </script>
</body>
</html>
