<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Blue Ice Christmas: Sensor Core</title>
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #001020 0%, #000000 100%); font-family: 'Times New Roman', serif; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        
        h1 { 
            position: absolute; top: 5%; width: 100%; text-align: center;
            color: #e0f7fa; font-size: 42px; margin: 0; font-weight: 100; 
            letter-spacing: 3px; 
            text-shadow: 0 0 15px #00bfff, 0 0 30px #00ffff; 
            font-family: 'Cinzel', serif; opacity: 1.0; 
            transition: opacity 0.5s;
        }

        .left-panel {
            position: absolute; left: 15px; top: 50%; transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 12px;
            pointer-events: auto; transition: opacity 0.5s;
        }
        .deco-btn {
            background: rgba(0, 20, 40, 0.4); border: 1px solid rgba(135, 206, 250, 0.5); 
            color: #e0ffff; width: 45px; height: 45px; border-radius: 50%;
            cursor: pointer; font-size: 20px;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.3s; backdrop-filter: blur(5px);
            box-shadow: 0 0 10px rgba(0, 191, 255, 0.2);
        }
        .deco-btn:active { background: #00bfff; color: #fff; transform: scale(1.1); }
        
        .bottom-panel {
            position: absolute; bottom: 30px; width: 100%;
            display: flex; flex-direction: column; align-items: center; gap: 12px;
            pointer-events: auto; transition: opacity 0.5s;
        }
        .btn-photo { 
            background: rgba(0, 100, 255, 0.2); border: 1px solid #87cefa; 
            color: #e0ffff; padding: 10px 30px; border-radius: 30px; 
            text-transform: uppercase; font-size: 14px; font-weight: bold; cursor: pointer;
            backdrop-filter: blur(5px); display: inline-block;
            box-shadow: 0 0 15px rgba(0,100,255,0.3);
        }
        
        .instruction {
            font-size: 13px; color: #e0ffff; font-weight: bold;
            text-shadow: 0 0 5px #00bfff; background: rgba(0, 20, 40, 0.7); 
            padding: 8px 16px; border-radius: 20px; text-align: center;
            line-height: 1.5; border: 1px solid rgba(135,206,250,0.3);
        }

        .hidden { opacity: 0; pointer-events: none; }
        #file-input { display: none; }
        
        /* å¯åŠ¨é®ç½©ï¼šiOSä¼ æ„Ÿå™¨éœ€è¦ç”¨æˆ·ç‚¹å‡»æˆæƒ */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            backdrop-filter: blur(10px);
        }
        .start-btn {
            padding: 15px 40px; font-size: 20px; color: #001020; 
            background: #00bfff; border: none; border-radius: 50px;
            box-shadow: 0 0 20px #00bfff; font-weight: bold; cursor: pointer;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% {box-shadow: 0 0 0 0 rgba(0,191,255, 0.7);} 70% {box-shadow: 0 0 0 15px rgba(0,191,255, 0);} 100% {box-shadow: 0 0 0 0 rgba(0,191,255, 0);} }
    </style>
    <style> @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap'); </style>
    <script type="importmap"> { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } } </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <h1>Merry Christmas</h1>
        <div class="left-panel" id="deco-panel">
            <button class="deco-btn" id="btn-add-star">â˜…</button>
            <button class="deco-btn" id="btn-add-gift">ğŸ</button>
            <button class="deco-btn" id="btn-add-sock">ğŸ§¦</button>
            <button class="deco-btn" id="btn-add-apple">ğŸ</button>
            <button class="deco-btn" id="btn-add-bauble">â—</button>
        </div>
        <div class="bottom-panel" id="bottom-panel">
            <label class="btn-photo">
                ğŸ“· ä¸Šä¼ ç…§ç‰‡
                <input type="file" id="file-input" multiple accept="image/*">
            </label>
            <div class="instruction" id="instruction-text">
                åŒæŒ‡å¼ å¼€ï¼šæ•£è½ | åŒæŒ‡æåˆï¼šè¿˜åŸ<br>
                æ™ƒåŠ¨æ‰‹æœºï¼šâ„ï¸æš´é£é›ª | å€¾æ–œï¼šæ—‹è½¬è§†è§’
            </div>
        </div>
    </div>

    <div id="start-overlay">
        <h2 style="color:#e0ffff; margin-bottom:30px; font-family:'Cinzel'">Blue Ice Christmas</h2>
        <button class="start-btn" id="btn-start">ç‚¹ å‡» å¼€å¯ â„ï¸</button>
        <p style="color:#88ccff; font-size:12px; margin-top:20px;">å¼€å¯é‡åŠ›æ„Ÿåº”ä½“éªŒæœ€ä½³æ•ˆæœ</p>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- é…ç½® ---
        const CONFIG = {
            colors: { bg: 0x000510, blueMain: 0x87cefa, whiteSilver: 0xffffff, fairyDust: 0xe0ffff },
            tree: { height: 26, radius: 9, count: 1200 },
            fairyDust: { count: 800 }
        };

        const STATE = { 
            mode: 'TREE', // TREE, SCATTER, FOCUS
            focusIndex: 0,
            rotationVelocity: 0,
            autoRotate: true,
            targetGroupPos: new THREE.Vector3(0,0,0),
            gyro: { x: 0, y: 0 } // å­˜å‚¨é™€èºä»ªæ•°æ®
        };

        // --- æ ¸å¿ƒå˜é‡ ---
        let scene, camera, renderer, composer;
        let mainGroup, treeGroup, snowSystem, ringGroup, lightTubeMesh;
        let clock = new THREE.Clock();
        let particles = []; 
        let photoMeshes = []; 
        let starGeo, ballGeo, glowTex, snowTex, giftTex, sockTex, appleTex; 
        let baseBlueMat, baseSilverMat;

        // --- åˆå§‹åŒ–å…¥å£ ---
        async function init() {
            createResources();
            initThree();
            setupLights();
            
            createTreeLeaves(); 
            createFairyDust();  
            createStringLights(); 
            createDecorations(); 
            createMagicRings(); 
            createTopStar();    
            createDefaultPhoto(); 
            createSnow(); 

            setupPostProcessing();
            setupEvents(); // æ›¿æ¢åŸæœ‰çš„äº‹ä»¶ç›‘å¬
            animate();
        }

        // --- èµ„æºç”Ÿæˆ (æ— éœ€åŠ è½½å¤–éƒ¨å›¾ç‰‡ï¼Œç§’å¼€çš„å…³é”®) ---
        function createEmojiTexture(emoji, size=64) {
            const cvs = document.createElement('canvas'); cvs.width = size; cvs.height = size;
            const ctx = cvs.getContext('2d'); ctx.font = `${size*0.8}px serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(emoji, size/2, size/2 + size*0.1);
            return new THREE.CanvasTexture(cvs);
        }

        function createResources() {
            const cvs = document.createElement('canvas'); cvs.width = 64; cvs.height = 64;
            const ctx = cvs.getContext('2d');
            const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
            grad.addColorStop(0, 'rgba(255,255,255,1)'); grad.addColorStop(0.4, 'rgba(100,200,255,0.5)'); grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,64,64);
            glowTex = new THREE.CanvasTexture(cvs);

            snowTex = createEmojiTexture('â„ï¸');
            giftTex = createEmojiTexture('ğŸ');
            sockTex = createEmojiTexture('ğŸ§¦');
            appleTex = createEmojiTexture('ğŸ');

            baseBlueMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.blueMain, roughness: 0.3, metalness: 0.7, emissive: 0x0044aa, emissiveIntensity: 0.2 });
            baseSilverMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.whiteSilver, roughness: 0.2, metalness: 0.9, emissive: 0x444455, emissiveIntensity: 0.2 });
            ballGeo = new THREE.SphereGeometry(0.5, 16, 16);
            
            const sShape = new THREE.Shape();
            for(let i=0; i<10; i++) { const r = i%2===0 ? 0.6 : 0.3; const a = i/10 * Math.PI*2; sShape.lineTo(Math.cos(a)*r, Math.sin(a)*r); }
            starGeo = new THREE.ExtrudeGeometry(sShape, { depth: 0.15, bevelEnabled:true, bevelThickness:0.05 });
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x000510, 0.012);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 50); camera.lookAt(0, 8, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping; renderer.toneMappingExposure = 2.5;
            container.appendChild(renderer.domElement);
            
            mainGroup = new THREE.Group(); 
            treeGroup = new THREE.Group();
            mainGroup.add(treeGroup); 
            scene.add(mainGroup);
        }

        function setupLights() {
            const ambient = new THREE.AmbientLight(0xddeeff, 1.2); scene.add(ambient);
            const spot = new THREE.SpotLight(0x00bfff, 120); spot.position.set(30, 60, 50); spot.angle = 0.5; scene.add(spot);
            const backLight = new THREE.DirectionalLight(0x00ffff, 2); backLight.position.set(-20, 20, -20); scene.add(backLight);
        }

        // --- ç²’å­ç³»ç»Ÿ ---
        class Particle {
            constructor(mesh, type) {
                this.mesh = mesh; this.type = type;
                this.basePos = mesh.position.clone(); this.baseScale = mesh.scale.x; this.baseRot = mesh.rotation.clone();
                this.blinkOffset = Math.random() * 100; this.blinkSpeed = 2 + Math.random() * 3;
                
                // ç´§å‡‘çƒä½“
                const rBase = type === 'FAIRY' ? 10 : 25; 
                const r = rBase + Math.random() * 10; 
                const theta = Math.random() * Math.PI * 2; 
                const phi = Math.acos(2 * Math.random() - 1);
                this.scatterPos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta) + 2, 
                    r * Math.cos(phi)
                );
            }

            update(dt, time) {
                if (this.type !== 'PHOTO' && this.mesh.material && this.mesh.material.emissive) {
                    this.mesh.material.emissiveIntensity = 0.3 + 0.7 * Math.sin(time * this.blinkSpeed + this.blinkOffset);
                }

                let targetPos = this.basePos; 
                let targetScale = this.baseScale;
                let targetRot = this.baseRot;
                
                if (STATE.mode === 'SCATTER' || STATE.mode === 'FOCUS') {
                    targetPos = this.scatterPos;
                    this.mesh.rotation.x += dt; this.mesh.rotation.y += dt;
                    
                    if (STATE.mode === 'FOCUS') {
                        if (this.type === 'PHOTO') {
                            const currentTarget = photoMeshes[STATE.focusIndex];
                            if (this.mesh === currentTarget.mesh) {
                                const inv = new THREE.Matrix4().copy(treeGroup.matrixWorld).invert();
                                targetPos = new THREE.Vector3(0, 5, 38).applyMatrix4(inv); // ç¨å¾®æ‹‰è¿‘ä¸€ç‚¹
                                
                                const aspect = currentTarget.aspect;
                                let scaleW = 6.0; let scaleH = 6.0;
                                if (aspect > 1) scaleH = scaleW / aspect; 
                                else scaleW = scaleH * aspect; 

                                this.mesh.position.lerp(targetPos, 8*dt);
                                this.mesh.scale.lerp(new THREE.Vector3(scaleW, scaleH, 1), 8*dt);
                                
                                const targetQuat = new THREE.Quaternion().copy(camera.quaternion); 
                                const parentInv = new THREE.Quaternion().copy(treeGroup.quaternion).invert();
                                targetQuat.premultiply(parentInv); 
                                this.mesh.quaternion.slerp(targetQuat, 10*dt);
                                return; 
                            } else { targetScale = 0; }
                        } 
                    }
                } else {
                    if (this.type.includes('DECO') || this.type === 'FAIRY') {
                        targetPos = this.basePos.clone();
                        targetPos.y += Math.sin(time*2 + this.mesh.id)*0.1;
                    }
                }
                
                this.mesh.position.lerp(targetPos, 4*dt);
                this.mesh.scale.lerp(new THREE.Vector3(targetScale,targetScale,targetScale), 4*dt);
                if(STATE.mode !== 'SCATTER' && STATE.mode !== 'FOCUS') { 
                    this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, targetRot.x, 3*dt); 
                    this.mesh.rotation.y = THREE.MathUtils.lerp(this.mesh.rotation.y, targetRot.y, 3*dt); 
                }
            }
        }

        function createTreeLeaves() {
            const geo = new THREE.TetrahedronGeometry(0.4, 0);
            for(let i=0; i<CONFIG.tree.count; i++) {
                const t = Math.random(); const h = CONFIG.tree.height; const r = CONFIG.tree.radius * (1 - t); const y = t * h - h/2 + 2; const angle = Math.random() * Math.PI * 2;
                const pos = new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r); pos.addScaledVector(new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5), 2);
                const mat = Math.random()>0.6 ? baseSilverMat.clone() : baseBlueMat.clone();
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos); mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6); mesh.scale.setScalar(0.4 + Math.random()*0.6);
                treeGroup.add(mesh); particles.push(new Particle(mesh, 'LEAF'));
            }
        }

        function createFairyDust() {
            const mat = new THREE.SpriteMaterial({ map: glowTex, color: 0xe0ffff, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending });
            for(let i=0; i<CONFIG.fairyDust.count; i++) {
                const t = Math.random(); const h = CONFIG.tree.height; const r = CONFIG.tree.radius * (1 - t) * 0.8; const y = t * h - h/2 + 2; const a = Math.random() * Math.PI * 2;
                const sprite = new THREE.Sprite(mat.clone());
                sprite.position.set(Math.cos(a)*r, y, Math.sin(a)*r);
                sprite.scale.setScalar(0.3 + Math.random()*0.3);
                treeGroup.add(sprite); particles.push(new Particle(sprite, 'FAIRY'));
            }
        }

        function createStringLights() {
            const curvePts = []; const h = CONFIG.tree.height;
            for(let i=0; i<=200; i++) { const t = i/200; const a = t*7*Math.PI*2; const y = t*h-h/2+1; const r = CONFIG.tree.radius*(1-t)+0.4; curvePts.push(new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r)); }
            const curve = new THREE.CatmullRomCurve3(curvePts);
            lightTubeMesh = new THREE.Mesh(new THREE.TubeGeometry(curve, 120, 0.05, 8, false), new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent:true, opacity:0.3 }));
            treeGroup.add(lightTubeMesh);
            const bulbGeo = new THREE.SphereGeometry(0.15); const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            for(let i=0; i<150; i++) { const pt = curve.getPoint(i/150); const mesh = new THREE.Mesh(bulbGeo, bulbMat.clone()); mesh.position.copy(pt); mesh.userData.blinkRate = 2+Math.random()*3; treeGroup.add(mesh); particles.push(new Particle(mesh, 'LIGHT')); scene.userData.bulbs = scene.userData.bulbs || []; scene.userData.bulbs.push(mesh); }
        }

        function createDecorations() { for(let i=0;i<3;i++) addDecoration('STAR'); for(let i=0;i<3;i++) addDecoration('GIFT'); for(let i=0;i<5;i++) addDecoration('BAUBLE'); }
        function addDecoration(type) {
            let mesh; const t = Math.random(); const h = CONFIG.tree.height; const y = t*h-h/2+2; const r = CONFIG.tree.radius*(1-t)+1.2; const a = Math.random()*Math.PI*2; const pos = new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r);
            if(type === 'STAR') { mesh = new THREE.Mesh(starGeo, baseSilverMat.clone()); mesh.scale.setScalar(1.3); }
            else if (type === 'GIFT') { mesh = new THREE.Sprite(new THREE.SpriteMaterial({ map: giftTex })); mesh.scale.setScalar(2.0); }
            else if (type === 'SOCK') { mesh = new THREE.Sprite(new THREE.SpriteMaterial({ map: sockTex })); mesh.scale.setScalar(2.0); }
            else if (type === 'APPLE') { mesh = new THREE.Sprite(new THREE.SpriteMaterial({ map: appleTex })); mesh.scale.setScalar(1.8); }
            else { mesh = new THREE.Mesh(ballGeo, Math.random()>0.5 ? baseBlueMat.clone() : baseSilverMat.clone()); mesh.scale.setScalar(0.8); }
            mesh.position.copy(pos); if(mesh.isMesh) mesh.lookAt(0, y, 0);
            treeGroup.add(mesh); const p = new Particle(mesh, 'DECO_'+type); p.baseScale = mesh.scale.x; mesh.scale.set(0,0,0); particles.push(p);
        }

        function createTopStar() {
            const geo = new THREE.OctahedronGeometry(1.5, 0); const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x88ccff, emissiveIntensity: 2 });
            const star = new THREE.Mesh(geo, mat); star.position.set(0, CONFIG.tree.height/2+2.5, 0); treeGroup.add(star);
        }

        function createDefaultPhoto() {
            const cvs = document.createElement('canvas'); cvs.width = 512; cvs.height = 512; const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#001133'; ctx.fillRect(0,0,512,512); ctx.strokeStyle = '#00bfff'; ctx.lineWidth = 20; ctx.strokeRect(20,20,472,472);
            ctx.font = 'bold 80px Arial'; ctx.fillStyle = '#e0ffff'; ctx.textAlign = 'center'; ctx.fillText("Happy", 256, 220); ctx.fillText("Holidays", 256, 320);
            addPhotoMesh(new THREE.CanvasTexture(cvs), 1.0); 
        }

        function addPhotoMesh(tex, aspect = 1.0) {
            const g = new THREE.Group(); 
            const photoGeo = new THREE.PlaneGeometry(1, 1);
            const photoMat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.8, metalness: 0.1, side: THREE.DoubleSide });
            const p = new THREE.Mesh(photoGeo, photoMat); 
            const frame = new THREE.Mesh(new THREE.BoxGeometry(1.1, 1.1, 0.05), baseSilverMat.clone());
            frame.position.z = -0.03;
            g.add(p); g.add(frame);
            
            const h = CONFIG.tree.height; const t = Math.random(); const y = t * (h - 6) - (h / 2 - 3); const r = CONFIG.tree.radius + 2.5; const angle = Math.random() * Math.PI * 2; 
            g.position.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
            g.lookAt(0, y, 0); g.rotateY(Math.PI);
            treeGroup.add(g); 
            const data = { mesh: g, aspect: aspect };
            particles.push(new Particle(g, 'PHOTO')); 
            photoMeshes.push(data);
        }

        function createMagicRings() {
            ringGroup = new THREE.Group(); const geo = new THREE.TorusGeometry(10, 0.1, 16, 100); const mat = new THREE.MeshBasicMaterial({ color: 0x00bfff, transparent: true, opacity: 0.5 });
            for(let i=0; i<3; i++) { const ring = new THREE.Mesh(geo, mat); ring.rotation.x = Math.PI/2; ring.position.y = -CONFIG.tree.height/2-1; ring.scale.setScalar(1+i*0.5); ringGroup.add(ring); } scene.add(ringGroup);
        }

        function createSnow() {
            const geo = new THREE.BufferGeometry(); 
            const pos = []; 
            for(let i=0; i<2000; i++) { pos.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100); }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            snowSystem = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffffff, size: 1.5, map: snowTex, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false })); 
            scene.add(snowSystem);
        }

        function setupPostProcessing() {
            const rp = new RenderPass(scene, camera); const bp = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bp.threshold = 0.1; bp.strength = 1.2; bp.radius = 0.6; composer = new EffectComposer(renderer); composer.addPass(rp); composer.addPass(bp);
        }

        // --- æ ¸å¿ƒä¿®æ”¹ï¼šä¼ æ„Ÿå™¨ä¸è§¦æ‘¸äº‹ä»¶ ---
        function setupEvents() {
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); composer.setSize(window.innerWidth,window.innerHeight); });
            document.getElementById('btn-add-star').onclick = () => addDecoration('STAR'); document.getElementById('btn-add-gift').onclick = () => addDecoration('GIFT'); document.getElementById('btn-add-sock').onclick = () => addDecoration('SOCK'); document.getElementById('btn-add-apple').onclick = () => addDecoration('APPLE'); document.getElementById('btn-add-bauble').onclick = () => addDecoration('BAUBLE');
            
            // å¯åŠ¨æŒ‰é’® (iOSå¿…é¡»é€šè¿‡ç‚¹å‡»è¯·æ±‚æƒé™)
            document.getElementById('btn-start').addEventListener('click', () => {
                const overlay = document.getElementById('start-overlay');
                overlay.style.opacity = '0';
                setTimeout(() => overlay.remove(), 500);
                
                // è¯·æ±‚é™€èºä»ªæƒé™ (iOS 13+)
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission().then(state => {
                        if(state === 'granted') window.addEventListener('deviceorientation', handleOrientation);
                    }).catch(console.error);
                } else {
                    window.addEventListener('deviceorientation', handleOrientation);
                }
            });

            // è§¦æ‘¸äº‹ä»¶
            let initialPinch = 0;
            document.addEventListener('touchstart', (e) => {
                if(e.touches.length === 2) {
                    initialPinch = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                }
            }, {passive: false});

            document.addEventListener('touchmove', (e) => {
                if(e.touches.length === 2) {
                    e.preventDefault(); // é˜»æ­¢é¡µé¢æ»šåŠ¨
                    const currentPinch = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                    
                    if(currentPinch > initialPinch + 50) {
                        // æ‰©æ•£
                        STATE.mode = 'SCATTER';
                        STATE.autoRotate = false;
                        toggleUI(false);
                    } else if(currentPinch < initialPinch - 50) {
                        // åˆä½“
                        STATE.mode = 'TREE';
                        STATE.autoRotate = true;
                        toggleUI(true);
                    }
                }
            }, {passive: false});
            
            // ç‚¹å‡»äº¤äº’
            document.addEventListener('click', (e) => {
                 // ç®€å•çš„ç‚¹å‡»æ£€æµ‹ï¼Œå¦‚æœæ˜¯æ•£è½æ¨¡å¼ï¼Œåˆ‡æ¢ç…§ç‰‡
                 if(STATE.mode === 'SCATTER' || STATE.mode === 'FOCUS') {
                    // å¦‚æœç‚¹åˆ°äº†æŒ‰é’®åŒºåŸŸå¿½ç•¥
                    if(e.target.closest('button') || e.target.closest('label')) return;
                    
                    if(STATE.mode === 'FOCUS') {
                        // åˆ‡æ¢ä¸‹ä¸€å¼ 
                        STATE.focusIndex = (STATE.focusIndex + 1) % photoMeshes.length;
                    } else {
                         STATE.mode = 'FOCUS';
                    }
                 }
            });

            // æ‘‡ä¸€æ‘‡æ£€æµ‹
            let lastX=0, lastY=0, lastZ=0;
            let lastShake = 0;
            window.addEventListener('devicemotion', (e) => {
                const acc = e.accelerationIncludingGravity;
                if(!acc) return;
                const now = performance.now();
                if(now - lastShake < 1000) return;

                const deltaX = Math.abs(acc.x - lastX);
                const deltaY = Math.abs(acc.y - lastY);
                const deltaZ = Math.abs(acc.z - lastZ);

                if(deltaX + deltaY + deltaZ > 25) { // é˜ˆå€¼
                    triggerSnowStorm();
                    lastShake = now;
                }
                lastX = acc.x; lastY = acc.y; lastZ = acc.z;
            });

            // æ–‡ä»¶ä¸Šä¼ 
            document.getElementById('file-input').addEventListener('change', (e) => {
                if(e.target.files && e.target.files.length > 0) {
                    Array.from(e.target.files).forEach(file => {
                        const reader = new FileReader();
                        reader.onload = (ev) => {
                            const img = new Image(); img.src = ev.target.result;
                            img.onload = () => {
                                const aspect = img.width / img.height;
                                new THREE.TextureLoader().load(ev.target.result, (tex) => {
                                    tex.colorSpace = THREE.SRGBColorSpace; 
                                    addPhotoMesh(tex, aspect);
                                    document.getElementById('instruction-text').innerText = "ç…§ç‰‡å·²æ·»åŠ ! åŒæŒ‡å¼ å¼€æ‰©æ•£";
                                });
                            }
                        };
                        reader.readAsDataURL(file);
                    });
                }
            });
        }

        function handleOrientation(e) {
            // beta: xè½´å€¾æ–œ (-180, 180), gamma: yè½´å€¾æ–œ (-90, 90)
            const x = e.gamma || 0; 
            const y = e.beta || 0;
            // å¹³æ»‘é˜»å°¼
            STATE.gyro.x = x * 0.05; 
            STATE.gyro.y = (y - 45) * 0.05; // å‡è®¾ç”¨æˆ·é€šå¸¸45åº¦è§’æ‹¿æ‰‹æœº
        }

        function triggerSnowStorm() {
            if(!snowSystem) return;
            const pos = snowSystem.geometry.attributes.position.array;
            for(let i=0; i<pos.length; i++) {
                pos[i] += (Math.random()-0.5) * 50; // ç¬é—´æ‰°ä¹±
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            
            // éœ‡åŠ¨åé¦ˆ
            if(navigator.vibrate) navigator.vibrate(200);
            
            const tip = document.getElementById('instruction-text');
            const old = tip.innerText;
            tip.innerText = "â„ï¸ æš´é£é›ªé™ä¸´! â„ï¸";
            setTimeout(()=> tip.innerText = old, 2000);
        }

        function toggleUI(show) {
            const left = document.querySelector('.left-panel');
            const bottom = document.querySelector('.bottom-panel');
            if(show) { left.classList.remove('hidden'); bottom.classList.remove('hidden'); } 
            else { left.classList.add('hidden'); bottom.classList.add('hidden'); }
        }

        function animate() {
            requestAnimationFrame(animate); 
            const dt = clock.getDelta(); 
            const time = clock.elapsedTime;
            
            // é™€èºä»ªæ§åˆ¶æ—‹è½¬
            if (STATE.mode !== 'FOCUS') {
                if (STATE.autoRotate) {
                    treeGroup.rotation.y += 0.3 * dt;
                }
                // å åŠ é™€èºä»ªè§†å·®
                mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, STATE.gyro.x * 0.5, 2*dt);
                mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, STATE.gyro.y * 0.5, 2*dt);
                treeGroup.position.lerp(STATE.targetGroupPos, 2 * dt);
            }

            particles.forEach(p => p.update(dt, time));
            if (lightTubeMesh) lightTubeMesh.visible = (STATE.mode === 'TREE');
            
            if(snowSystem) { 
                const pos = snowSystem.geometry.attributes.position.array; 
                for(let i=0; i<2000; i++) { 
                    pos[i*3+1] -= (5 + Math.sin(time+i)*2) * dt; // é£˜é›ª
                    if(pos[i*3+1] < -50) { pos[i*3+1] = 50 + Math.random() * 5; }
                } 
                snowSystem.geometry.attributes.position.needsUpdate = true; 
            }
            if (scene.userData.bulbs) scene.userData.bulbs.forEach(b => b.material.color.setHSL(0.6, 1.0, 0.5 + 0.5*Math.sin(time*b.userData.blinkRate))); 
            composer.render();
        }
    </script>
</body>
</html>
