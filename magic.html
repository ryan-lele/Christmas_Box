<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>North Pole Hologram Projector v4.0 CN</title>
    
    <style>
        /* Ê®°Êãü Cinzel Âíå Tech Â≠ó‰Ωì */
        @font-face {
            font-family: 'TechMono';
            src: local('Courier New'), local('Consolas'), monospace;
        }
        @font-face {
            font-family: 'MagicSerif';
            src: local('Times New Roman'), local('Songti SC'), serif;
        }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://registry.npmmirror.com/three/0.160.0/files/build/three.module.js",
            "three/addons/": "https://registry.npmmirror.com/three/0.160.0/files/examples/jsm/",
            "@mediapipe/tasks-vision": "./js/vision_bundle.js"
        }
    }
    </script>

    <style>
        /* --- Ê†∏ÂøÉÂ∏ÉÂ±Ä --- */
        body {
            margin: 0; padding: 0; background-color: #000000;
            overflow: hidden; 
            font-family: 'TechMono', monospace; /* ‰ΩøÁî®Êú¨Âú∞Â≠ó‰Ωì */
            color: #00ffea; height: 100vh; width: 100vw;
        }

        /* --- ÁîªÂ∏ÉÂ±Ç --- */
        #hologram-canvas {
            display: block; position: absolute; top: 0; left: 0;
            z-index: 1; width: 100%; height: 100%;
        }

        /* --- HUD ÁïåÈù¢Â±Ç --- */
        .hud-overlay {
            position: absolute; z-index: 20; width: 100%;
            pointer-events: none; padding: 20px; box-sizing: border-box;
        }
        .hud-top {
            top: 0; border-bottom: 1px solid rgba(0, 255, 234, 0.3);
            display: flex; justify-content: space-between;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }
        .hud-bottom {
            bottom: 0; text-align: center; opacity: 0.9;
            font-size: 12px; padding-bottom: 20px;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
        }
        
        .status-dot {
            display: inline-block; width: 8px; height: 8px;
            background-color: #00ffea; border-radius: 50%;
            box-shadow: 0 0 8px #00ffea; margin-right: 5px;
            animation: pulse 2s infinite;
        }
        .scan-line {
            position: absolute; top: 0; left: 0; width: 100%; height: 5px;
            background: rgba(0, 255, 234, 0.2); box-shadow: 0 0 10px rgba(0, 255, 234, 0.5);
            animation: scan 4s linear infinite; z-index: 5; pointer-events: none;
        }
        .back-btn {
            pointer-events: auto; color: #00ffea; text-decoration: none;
            border: 1px solid #00ffea; padding: 5px 10px; font-size: 12px;
            text-transform: uppercase; background: rgba(0, 20, 20, 0.8); cursor: pointer;
        }

        /* --- Â∑¶‰æßË£ÖÈ•∞ÊåâÈíÆ --- */
        .left-panel {
            position: absolute; left: 15px; top: 55%; transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 15px;
            pointer-events: auto; z-index: 15;
        }
        .deco-btn {
            background: rgba(0, 20, 40, 0.4); border: 1px solid rgba(0, 255, 234, 0.5); 
            color: #00ffea; width: 45px; height: 45px; border-radius: 50%;
            cursor: pointer; font-size: 20px;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.3s; backdrop-filter: blur(5px);
            box-shadow: 0 0 10px rgba(0, 255, 234, 0.2);
        }
        .deco-btn:hover { background: #00ffea; color: #000; transform: scale(1.1); }

        /* --- Â∫ïÈÉ®ÊéßÂà∂ --- */
        .control-panel {
            pointer-events: auto; display: inline-block; margin-bottom: 10px;
        }
        .btn-photo { 
            background: rgba(0, 100, 255, 0.15); border: 1px solid #00ffea; 
            color: #e0ffff; padding: 8px 20px; border-radius: 30px; 
            text-transform: uppercase; font-size: 11px; font-weight: bold; cursor: pointer;
            backdrop-filter: blur(5px); display: inline-block; font-family: 'TechMono', monospace;
        }
        
        /* --- ÊëÑÂÉèÂ§¥Á™óÂè£ --- */
        #webcam-wrapper { 
            position: absolute; bottom: 100px; right: 20px; width: 120px; height: 90px; 
            border: 1px solid #00ffea; border-radius: 6px; overflow: hidden; opacity: 0.8; 
            transform: scaleX(-1); background: #000; pointer-events: none; z-index: 15;
        }
        #gesture-status { 
            position: absolute; bottom: 0; left: 0; width: 100%; 
            background: rgba(0, 20, 20, 0.9); color: #00ffea; 
            font-size: 10px; text-align: center; padding: 2px 0;
        }
        #webcam-preview { width: 100%; height: 100%; object-fit: cover; }
        #file-input { display: none; }

        .hidden { opacity: 0; pointer-events: none; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.4; } 100% { opacity: 1; } }
        @keyframes scan { 0% { top: -10%; opacity: 0; } 50% { opacity: 1; } 100% { top: 110%; opacity: 0; } }
    </style>
</head>
<body>

    <div class="scan-line"></div>
    <div class="hud-overlay hud-top">
        <div><span class="status-dot"></span><span id="txt-proj">PROJECTOR v3.0</span></div>
        <a href="javascript:history.back()" class="back-btn" id="txt-exit">Exit</a>
    </div>

    <canvas id="hologram-canvas"></canvas>

    <div class="left-panel" id="deco-panel">
        <button class="deco-btn" id="btn-add-star">‚òÖ</button>
        <button class="deco-btn" id="btn-add-gift">üéÅ</button>
        <button class="deco-btn" id="btn-add-sock">üß¶</button>
        <button class="deco-btn" id="btn-add-apple">üçé</button>
        <button class="deco-btn" id="btn-add-bauble">‚óè</button>
    </div>

    <div id="webcam-wrapper">
        <video id="webcam" autoplay playsinline style="display:none;"></video>
        <canvas id="webcam-preview"></canvas>
        <div id="gesture-status">Init...</div>
    </div>

    <div class="hud-overlay hud-bottom">
        <div class="control-panel">
            <label class="btn-photo">
                <span id="txt-upload">üì∑ UPLOAD PHOTO</span>
                <input type="file" id="file-input" multiple accept="image/*">
            </label>
        </div>
        <br>
        <span id="txt-sys">// SYSTEM: RENDERING GIFT...</span><br>
        <span id="txt-target">// TARGET: </span> <span id="target-name">UNKNOWN</span><br>
        <span id="txt-gesture" style="color: #fff; text-shadow: 0 0 5px cyan; font-size: 11px; display:block; margin-top:8px; font-weight:bold; letter-spacing: 1px;">
            Initializing Gestures...
        </span>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- Â≠óÂÖ∏Á≥ªÁªü ---
        const dictionary = {
            en: {
                projector: "PROJECTOR v3.0", exit: "EXIT", system: "// SYSTEM: PARTICLE TREE ACTIVE", target: "// TARGET: ",
                upload: "üì∑ UPLOAD PHOTO", camReady: "CAM READY",
                g_init: "‚úã OPEN: Scatter | ‚òùÔ∏è POINT: View Photo | ‚úä FIST: Restore",
                g_point: "‚òùÔ∏è POINT: Viewing Photo (Swipe L/R)", g_fist: "‚úä FIST: Restore & Rotate", g_open: "‚úã OPEN: Scattering...",
                g_hover: "HOVERING", photoAdded: "Photo Added! Point ‚òùÔ∏è to view."
            },
            zh: {
                projector: "ÂÖ®ÊÅØÊäïÂΩ±‰ª™ v3.0", exit: "ÈÄÄÂá∫", system: "// Á≥ªÁªü: Á≤íÂ≠êÂú£ËØûÊ†ëÂ∑≤ÊøÄÊ¥ª", target: "// ÈîÅÂÆöÁõÆÊ†á: ",
                upload: "üì∑ ‰∏ä‰º†ÁÖßÁâá", camReady: "ÊëÑÂÉèÂ§¥Â∞±Áª™",
                g_init: "‚úãÂº†ÂºÄ:Êï£ËêΩ | ‚òùÔ∏èÂçïÊåá:ÁúãÁÖßÁâá | ‚úäÊè°Êã≥:ËøòÂéü",
                g_point: "‚òùÔ∏è ÂçïÊåá: Êü•ÁúãÁÖßÁâá (Â∑¶Âè≥ÊªëÂä®ÂàáÂõæ)", g_fist: "‚úä Êè°Êã≥: ËøòÂéü & ÊóãËΩ¨", g_open: "‚úã Âº†ÂºÄ: Êï£ËêΩË∑üÈöè",
                g_hover: "ÊÇ¨ÂÅú‰∏≠", photoAdded: "ÁÖßÁâáÂ∑≤Ê∑ªÂä†! ÂçïÊåá ‚òùÔ∏è Êü•Áúã"
            }
        };

        const urlParams = new URLSearchParams(window.location.search);
        const langParam = urlParams.get('lang');
        const currentLang = (langParam === 'zh') ? 'zh' : 'en';
        const data = dictionary[currentLang];
        let rawName = urlParams.get('name');
        const childName = rawName ? rawName.replace(/</g, "&lt;").replace(/>/g, "&gt;") : "USER";

        document.getElementById('txt-proj').textContent = data.projector;
        document.getElementById('txt-exit').textContent = data.exit;
        document.getElementById('txt-sys').textContent = data.system;
        document.getElementById('txt-target').textContent = data.target;
        document.getElementById('target-name').textContent = childName.toUpperCase();
        document.getElementById('txt-upload').textContent = data.upload;
        document.getElementById('txt-gesture').textContent = data.g_init;

        // --- Three.js ÂèòÈáè ---
        const CONFIG = { colors: { bg: 0x000510, blueMain: 0x87cefa, whiteSilver: 0xffffff, fairyDust: 0xe0ffff }, tree: { height: 26, radius: 9, count: 1200 }, fairyDust: { count: 800 } };
        const STATE = { mode: 'TREE', focusIndex: 0, hand: { detected: false, x: 0 }, rotationVelocity: 0, targetGroupPos: new THREE.Vector3(0,0,0) };
        let swipe = { lastX: null, lastTime: 0, cooldown: 500 };
        let scene, camera, renderer, composer;
        let mainGroup, treeGroup, snowSystem, ringGroup, lightTubeMesh;
        let clock = new THREE.Clock();
        let particles = []; let photoMeshes = []; 
        let starGeo, ballGeo, glowTex, snowTex, giftTex, sockTex, appleTex; 
        let baseBlueMat, baseSilverMat;
        let handLandmarker, video, webcamCanvas, webcamCtx;

        async function init() {
            createResources();
            initThree();
            setupLights();
            createTreeLeaves(); createFairyDust(); createStringLights(); createDecorations(); createMagicRings(); createTopStar(); createDefaultPhoto(); createSnow();
            setupPostProcessing();
            setupEvents();
            animate();
            // ÈáçÁÇπÔºöMediaPipe ÂàùÂßãÂåñ
            initMediaPipe().catch(e => {
                console.error(e);
                document.getElementById('txt-gesture').innerText = "ERROR: Ê®°ÂûãÂä†ËΩΩÂ§±Ë¥• (Ê£ÄÊü•Êñá‰ª∂Ë∑ØÂæÑ)";
            });
        }

        function createEmojiTexture(emoji, size=64) {
            const cvs = document.createElement('canvas'); cvs.width = size; cvs.height = size;
            const ctx = cvs.getContext('2d'); ctx.font = `${size*0.8}px serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(emoji, size/2, size/2 + size*0.1);
            return new THREE.CanvasTexture(cvs);
        }

        function createResources() {
            const cvs = document.createElement('canvas'); cvs.width = 64; cvs.height = 64;
            const ctx = cvs.getContext('2d'); const grad = ctx.createRadialGradient(32,32,0, 32,32,32); grad.addColorStop(0, 'rgba(255,255,255,1)'); grad.addColorStop(0.4, 'rgba(100,200,255,0.5)'); grad.addColorStop(1, 'rgba(0,0,0,0)'); ctx.fillStyle = grad; ctx.fillRect(0,0,64,64); glowTex = new THREE.CanvasTexture(cvs);
            snowTex = createEmojiTexture('‚ùÑÔ∏è'); giftTex = createEmojiTexture('üéÅ'); sockTex = createEmojiTexture('üß¶'); appleTex = createEmojiTexture('üçé');
            baseBlueMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.blueMain, roughness: 0.3, metalness: 0.7, emissive: 0x0044aa, emissiveIntensity: 0.2 });
            baseSilverMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.whiteSilver, roughness: 0.2, metalness: 0.9, emissive: 0x444455, emissiveIntensity: 0.2 });
            ballGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const sShape = new THREE.Shape(); for(let i=0; i<10; i++) { const r = i%2===0 ? 0.6 : 0.3; const a = i/10 * Math.PI*2; sShape.lineTo(Math.cos(a)*r, Math.sin(a)*r); } starGeo = new THREE.ExtrudeGeometry(sShape, { depth: 0.15, bevelEnabled:true, bevelThickness:0.05 });
        }

        function initThree() {
            const canvas = document.getElementById('hologram-canvas');
            scene = new THREE.Scene(); 
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 50); camera.lookAt(0, 8, 0);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); renderer.toneMapping = THREE.ReinhardToneMapping; renderer.toneMappingExposure = 2.5;
            mainGroup = new THREE.Group(); treeGroup = new THREE.Group(); mainGroup.add(treeGroup); scene.add(mainGroup);
        }

        function setupLights() { const ambient = new THREE.AmbientLight(0xddeeff, 1.2); scene.add(ambient); const spot = new THREE.SpotLight(0x00bfff, 120); spot.position.set(30, 60, 50); spot.angle = 0.5; scene.add(spot); const backLight = new THREE.DirectionalLight(0x00ffff, 2); backLight.position.set(-20, 20, -20); scene.add(backLight); }

        class Particle {
            constructor(mesh, type) {
                this.mesh = mesh; this.type = type; this.basePos = mesh.position.clone(); this.baseScale = mesh.scale.x; this.baseRot = mesh.rotation.clone(); this.blinkOffset = Math.random() * 100; this.blinkSpeed = 2 + Math.random() * 3;
                const rBase = type === 'FAIRY' ? 10 : 25; const r = rBase + Math.random() * 10; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                this.scatterPos = new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta) + 2, r * Math.cos(phi));
            }
            update(dt, time) {
                if (this.type !== 'PHOTO' && this.mesh.material && this.mesh.material.emissive) { this.mesh.material.emissiveIntensity = 0.3 + 0.7 * Math.sin(time * this.blinkSpeed + this.blinkOffset); }
                let targetPos = this.basePos; let targetScale = this.baseScale; let targetRot = this.baseRot;
                if (STATE.mode === 'SCATTER' || STATE.mode === 'FOCUS') {
                    targetPos = this.scatterPos; this.mesh.rotation.x += dt; this.mesh.rotation.y += dt;
                    if (STATE.mode === 'FOCUS') {
                        if (this.type === 'PHOTO') {
                            const currentTarget = photoMeshes[STATE.focusIndex];
                            if (this.mesh === currentTarget.mesh) {
                                const inv = new THREE.Matrix4().copy(treeGroup.matrixWorld).invert(); targetPos = new THREE.Vector3(0, 5, 40).applyMatrix4(inv); 
                                const aspect = currentTarget.aspect; let scaleW = 5.0; let scaleH = 5.0; if (aspect > 1) scaleH = scaleW / aspect; else scaleW = scaleH * aspect; 
                                this.mesh.position.lerp(targetPos, 8*dt); this.mesh.scale.lerp(new THREE.Vector3(scaleW, scaleH, 1), 8*dt);
                                const targetQuat = new THREE.Quaternion(); targetQuat.copy(camera.quaternion); const parentInv = new THREE.Quaternion().copy(treeGroup.quaternion).invert(); targetQuat.premultiply(parentInv); this.mesh.quaternion.slerp(targetQuat, 10*dt); return; 
                            } else { targetScale = 0; }
                        } 
                    }
                } else { if (this.type.includes('DECO') || this.type === 'FAIRY') { targetPos = this.basePos.clone(); targetPos.y += Math.sin(time*2 + this.mesh.id)*0.1; } }
                this.mesh.position.lerp(targetPos, 4*dt); this.mesh.scale.lerp(new THREE.Vector3(targetScale,targetScale,targetScale), 4*dt);
                if(STATE.mode !== 'SCATTER' && STATE.mode !== 'FOCUS') { this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, targetRot.x, 3*dt); this.mesh.rotation.y = THREE.MathUtils.lerp(this.mesh.rotation.y, targetRot.y, 3*dt); }
            }
        }

        function createTreeLeaves() { const geo = new THREE.TetrahedronGeometry(0.4, 0); for(let i=0; i<CONFIG.tree.count; i++) { const t = Math.random(); const h = CONFIG.tree.height; const r = CONFIG.tree.radius * (1 - t); const y = t * h - h/2 + 2; const angle = Math.random() * Math.PI * 2; const pos = new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r); pos.addScaledVector(new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5), 2); const mat = Math.random()>0.6 ? baseSilverMat.clone() : baseBlueMat.clone(); const mesh = new THREE.Mesh(geo, mat); mesh.position.copy(pos); mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6); mesh.scale.setScalar(0.4 + Math.random()*0.6); treeGroup.add(mesh); particles.push(new Particle(mesh, 'LEAF')); } }
        function createFairyDust() { const mat = new THREE.SpriteMaterial({ map: glowTex, color: 0xe0ffff, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending }); for(let i=0; i<CONFIG.fairyDust.count; i++) { const t = Math.random(); const h = CONFIG.tree.height; const r = CONFIG.tree.radius * (1 - t) * 0.8; const y = t * h - h/2 + 2; const a = Math.random() * Math.PI * 2; const sprite = new THREE.Sprite(mat.clone()); sprite.position.set(Math.cos(a)*r, y, Math.sin(a)*r); sprite.scale.setScalar(0.3 + Math.random()*0.3); treeGroup.add(sprite); particles.push(new Particle(sprite, 'FAIRY')); } }
        function createStringLights() { const curvePts = []; const h = CONFIG.tree.height; for(let i=0; i<=200; i++) { const t = i/200; const a = t*7*Math.PI*2; const y = t*h-h/2+1; const r = CONFIG.tree.radius*(1-t)+0.4; curvePts.push(new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r)); } const curve = new THREE.CatmullRomCurve3(curvePts); lightTubeMesh = new THREE.Mesh(new THREE.TubeGeometry(curve, 120, 0.05, 8, false), new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent:true, opacity:0.3 })); treeGroup.add(lightTubeMesh); const bulbGeo = new THREE.SphereGeometry(0.15); const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); for(let i=0; i<150; i++) { const pt = curve.getPoint(i/150); const mesh = new THREE.Mesh(bulbGeo, bulbMat.clone()); mesh.position.copy(pt); mesh.userData.blinkRate = 2+Math.random()*3; treeGroup.add(mesh); particles.push(new Particle(mesh, 'LIGHT')); scene.userData.bulbs = scene.userData.bulbs || []; scene.userData.bulbs.push(mesh); } }
        function createDecorations() { for(let i=0;i<3;i++) addDecoration('STAR'); for(let i=0;i<3;i++) addDecoration('GIFT'); for(let i=0;i<5;i++) addDecoration('BAUBLE'); }
        function addDecoration(type) { let mesh; const t = Math.random(); const h = CONFIG.tree.height; const y = t*h-h/2+2; const r = CONFIG.tree.radius*(1-t)+1.2; const a = Math.random()*Math.PI*2; const pos = new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r); if(type === 'STAR') { mesh = new THREE.Mesh(starGeo, baseSilverMat.clone()); mesh.scale.setScalar(1.3); } else if (type === 'GIFT') { mesh = new THREE.Sprite(new THREE.SpriteMaterial({ map: giftTex })); mesh.scale.setScalar(2.0); } else if (type === 'SOCK') { mesh = new THREE.Sprite(new THREE.SpriteMaterial({ map: sockTex })); mesh.scale.setScalar(2.0); } else if (type === 'APPLE') { mesh = new THREE.Sprite(new THREE.SpriteMaterial({ map: appleTex })); mesh.scale.setScalar(1.8); } else { mesh = new THREE.Mesh(ballGeo, Math.random()>0.5 ? baseBlueMat.clone() : baseSilverMat.clone()); mesh.scale.setScalar(0.8); } mesh.position.copy(pos); if(mesh.isMesh) mesh.lookAt(0, y, 0); treeGroup.add(mesh); const p = new Particle(mesh, 'DECO_'+type); p.baseScale = mesh.scale.x; mesh.scale.set(0,0,0); particles.push(p); }
        function createTopStar() { const geo = new THREE.OctahedronGeometry(1.5, 0); const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x88ccff, emissiveIntensity: 2 }); const star = new THREE.Mesh(geo, mat); star.position.set(0, CONFIG.tree.height/2+2.5, 0); treeGroup.add(star); }
        function createDefaultPhoto() { const cvs = document.createElement('canvas'); cvs.width = 512; cvs.height = 512; const ctx = cvs.getContext('2d'); ctx.fillStyle = '#001133'; ctx.fillRect(0,0,512,512); ctx.strokeStyle = '#00bfff'; ctx.lineWidth = 20; ctx.strokeRect(20,20,472,472); ctx.font = 'bold 80px Arial'; ctx.fillStyle = '#e0ffff'; ctx.textAlign = 'center'; ctx.fillText("Happy", 256, 220); ctx.fillText("Holidays", 256, 320); addPhotoMesh(new THREE.CanvasTexture(cvs), 1.0); }
        function addPhotoMesh(tex, aspect = 1.0) { const g = new THREE.Group(); const photoGeo = new THREE.PlaneGeometry(1, 1); const photoMat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.8, metalness: 0.1, side: THREE.DoubleSide }); const p = new THREE.Mesh(photoGeo, photoMat); const frame = new THREE.Mesh(new THREE.BoxGeometry(1.1, 1.1, 0.05), baseSilverMat.clone()); frame.position.z = -0.03; g.add(p); g.add(frame); const h = CONFIG.tree.height; const t = Math.random(); const y = t * (h - 6) - (h / 2 - 3); const r = CONFIG.tree.radius + 2.5; const angle = Math.random() * Math.PI * 2; g.position.set(Math.cos(angle) * r, y, Math.sin(angle) * r); g.lookAt(0, y, 0); g.rotateY(Math.PI); treeGroup.add(g); const data = { mesh: g, aspect: aspect }; particles.push(new Particle(g, 'PHOTO')); photoMeshes.push(data); }
        function createMagicRings() { ringGroup = new THREE.Group(); const geo = new THREE.TorusGeometry(10, 0.1, 16, 100); const mat = new THREE.MeshBasicMaterial({ color: 0x00bfff, transparent: true, opacity: 0.5 }); for(let i=0; i<3; i++) { const ring = new THREE.Mesh(geo, mat); ring.rotation.x = Math.PI/2; ring.position.y = -CONFIG.tree.height/2-1; ring.scale.setScalar(1+i*0.5); ringGroup.add(ring); } scene.add(ringGroup); }
        function createSnow() { const geo = new THREE.BufferGeometry(); const pos = []; for(let i=0; i<2000; i++) { pos.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100); } geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3)); snowSystem = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffffff, size: 1.5, map: snowTex, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false })); scene.add(snowSystem); }
        function setupPostProcessing() { const rp = new RenderPass(scene, camera); const bp = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85); bp.threshold = 0.1; bp.strength = 1.2; bp.radius = 0.6; composer = new EffectComposer(renderer); composer.addPass(rp); composer.addPass(bp); }
        function setupEvents() { window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); composer.setSize(window.innerWidth,window.innerHeight); }); document.getElementById('btn-add-star').onclick = () => addDecoration('STAR'); document.getElementById('btn-add-gift').onclick = () => addDecoration('GIFT'); document.getElementById('btn-add-sock').onclick = () => addDecoration('SOCK'); document.getElementById('btn-add-apple').onclick = () => addDecoration('APPLE'); document.getElementById('btn-add-bauble').onclick = () => addDecoration('BAUBLE'); const fileInput = document.getElementById('file-input'); fileInput.addEventListener('change', (e) => { if(e.target.files && e.target.files.length > 0) { Array.from(e.target.files).forEach(file => { const reader = new FileReader(); reader.onload = (ev) => { const img = new Image(); img.src = ev.target.result; img.onload = () => { const aspect = img.width / img.height; new THREE.TextureLoader().load(ev.target.result, (tex) => { tex.colorSpace = THREE.SRGBColorSpace; addPhotoMesh(tex, aspect); STATE.focusIndex = photoMeshes.length - 1; document.getElementById('txt-gesture').innerText = data.photoAdded; }); } }; reader.readAsDataURL(file); }); fileInput.value = ''; } }); }
        
        // --- Êú¨Âú∞Âåñ MediaPipe Âä†ËΩΩÈÄªËæë ---
        async function initMediaPipe() {
            video = document.getElementById('webcam'); webcamCanvas = document.getElementById('webcam-preview'); webcamCtx = webcamCanvas.getContext('2d'); webcamCanvas.width = 160; webcamCanvas.height = 120;
            
            // ÂÖ≥ÈîÆÔºöÊåáÂêëÊú¨Âú∞ wasm Êñá‰ª∂Â§π
            const vision = await FilesetResolver.forVisionTasks("./wasm");
            
            handLandmarker = await HandLandmarker.createFromOptions(vision, { 
                baseOptions: { 
                    // ÂÖ≥ÈîÆÔºöÊåáÂêëÊú¨Âú∞Ê®°ÂûãÊñá‰ª∂
                    modelAssetPath: "./wasm/hand_landmarker.task",
                    delegate: "GPU" 
                }, 
                runningMode: "VIDEO", 
                numHands: 1 
            });
            
            if (navigator.mediaDevices?.getUserMedia) { 
                const stream = await navigator.mediaDevices.getUserMedia({ video: true }); 
                video.srcObject = stream; 
                video.addEventListener("loadeddata", predictWebcam); 
                document.getElementById('gesture-status').innerText = data.camReady; 
            }
        }

        let lastTime = -1; 
        async function predictWebcam() { if(video.currentTime !== lastTime && handLandmarker) { lastTime = video.currentTime; const res = handLandmarker.detectForVideo(video, performance.now()); webcamCtx.clearRect(0,0,160,120); webcamCtx.drawImage(video,0,0,160,120); if(res.landmarks && res.landmarks.length > 0) { processGestures(res.landmarks[0]); webcamCtx.fillStyle='cyan'; for(let p of res.landmarks[0]) { webcamCtx.beginPath(); webcamCtx.arc(p.x*160, p.y*120, 2, 0, 7); webcamCtx.fill(); } } else { STATE.hand.detected = false; } } requestAnimationFrame(predictWebcam); }
        function switchPhoto(dir) { const now = performance.now(); if (now - swipe.lastTime < swipe.cooldown) return; const len = photoMeshes.length; if (len === 0) return; STATE.focusIndex = (STATE.focusIndex + dir + len) % len; swipe.lastTime = now; document.getElementById('txt-gesture').innerText = `${data.g_point} [${STATE.focusIndex+1}/${len}]`; }
        function findClosestPhotoIndex() { let closestIndex = 0; let minDistance = Infinity; photoMeshes.forEach((item, index) => { const worldPos = new THREE.Vector3(); item.mesh.getWorldPosition(worldPos); const dist = camera.position.distanceTo(worldPos); if(dist < minDistance) { minDistance = dist; closestIndex = index; } }); return closestIndex; }
        
        function processGestures(lm) {
            STATE.hand.detected = true; const palmX = (lm[9].x - 0.5) * 2; const palmY = (lm[9].y - 0.5) * 2; const wrist = lm[0]; const indexTip = lm[8]; const middleTip = lm[12]; const ringTip = lm[16]; const pinkyTip = lm[20];
            let spread = 0; [indexTip, middleTip, ringTip, pinkyTip].forEach(t => spread += Math.hypot(t.x-wrist.x, t.y-wrist.y)); spread /= 4; 
            const dIndex = Math.hypot(indexTip.x - wrist.x, indexTip.y - wrist.y); const dMiddle = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y); const dRing = Math.hypot(ringTip.x - wrist.x, ringTip.y - wrist.y); const dPinky = Math.hypot(pinkyTip.x - wrist.x, pinkyTip.y - wrist.y);
            const isPointing = (dIndex > 0.25) && (dMiddle < 0.25) && (dRing < 0.25) && (dPinky < 0.25);
            let msg = ""; 
            if (isPointing && (STATE.mode === 'SCATTER' || STATE.mode === 'FOCUS')) {
                if (STATE.mode === 'SCATTER') { STATE.focusIndex = findClosestPhotoIndex(); }
                STATE.mode = 'FOCUS'; 
                if (swipe.lastX !== null) { const diff = indexTip.x - swipe.lastX; if (diff > 0.05) switchPhoto(-1); else if (diff < -0.05) switchPhoto(1); }
                swipe.lastX = indexTip.x; msg = data.g_point;
            } else if (spread < 0.25) { STATE.mode = 'TREE'; STATE.targetGroupPos.set(0,0,0); STATE.rotationVelocity = THREE.MathUtils.lerp(STATE.rotationVelocity, -palmX * 3.0, 0.1); msg = data.g_fist; } 
            else if (spread > 0.55) { STATE.mode = 'SCATTER'; swipe.lastX = null; STATE.targetGroupPos.x = -palmX * 20; STATE.targetGroupPos.y = palmY * 15; STATE.rotationVelocity = -palmX * 2.0; msg = data.g_open; } 
            else { if (STATE.mode === 'FOCUS') STATE.mode = 'SCATTER'; if (STATE.mode === 'SCATTER') { msg = data.g_hover; } else { STATE.mode = 'TREE'; STATE.targetGroupPos.set(0,0,0); msg = data.g_hover; } } 
            document.getElementById('txt-gesture').innerText = msg;
        }

        function animate() {
            requestAnimationFrame(animate); 
            const dt = clock.getDelta(); const time = clock.elapsedTime;
            if (STATE.mode !== 'FOCUS') { treeGroup.rotation.y += STATE.rotationVelocity * dt; treeGroup.position.lerp(STATE.targetGroupPos, 2 * dt); }
            particles.forEach(p => p.update(dt, time));
            if (lightTubeMesh) lightTubeMesh.visible = (STATE.mode === 'TREE');
            if(snowSystem) { const pos = snowSystem.geometry.attributes.position.array; for(let i=0; i<2000; i++) { pos[i*3+1] -= 5 * dt; if(pos[i*3+1] < -50) { pos[i*3+1] = 50 + Math.random() * 5; } } snowSystem.geometry.attributes.position.needsUpdate = true; }
            if (scene.userData.bulbs) scene.userData.bulbs.forEach(b => b.material.color.setHSL(0.6, 1.0, 0.5 + 0.5*Math.sin(time*b.userData.blinkRate))); 
            composer.render();
        }
        init();
    </script>
</body>
</html>